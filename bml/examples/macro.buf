# macro testing

# macro dot(a, b) a.x * b.x + a.y * b.y
# macro SCALE_BY_PI(a) 3.14159 * a
# macro sqrt(a, b) (0.0 - a)
# macro dist(a, b) sqrt(dot(a - b, a - b))

macro E(b) b + 2
macro PI(a, b) a + E(b)

vec1 = [1, 2, 3]
vec2 = [4, 5, 6]
x = PI(10, 2)

# expand_macro() -> Vec<Token> {
#     let args
# 
#     while !paren {
#         let arg
# 
#         while !comma && !paren {
#             let template_token = token.advance()
# 
#             if template_token.is_macro() {
#                 let macro_tokens = expand_macro(template_token)
# 
#                 arg.add_all(macro_tokens)
#             } else {
#                 arg.add(template_token)
#             }
#         }
# 
#         args.add(arg)
#     }
# 
#     let call = macro.get(token)
# 
#     return call.expand(args) 
# }
# loop {
#     token = advance()
#     if token.is_identifier() && macros.contains(token) {
#         let args
# 
#         while peek() != right_paren {
#             let arg
# 
#             while peek() != comma && peek() != comma {
#                 arg_token = peek()
# 
#                 if arg_token.is_identifier() && macros.contains(arg_token) {
# 
#                 }
#             }
#         }
#     }
# }